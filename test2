#!/usr/bin/env python3
import re
import json
import xlsxwriter
from tqdm import tqdm

INPUT_FILE  = "input.txt"
OUTPUT_FILE = "ParsedLogs_Test.xlsx"

# Detect Type B by presence of ~#~
def is_type_b(line):
    return "~#~" in line

def flatten(obj, prefix=""):
    flat = {}
    if isinstance(obj, dict):
        for k, v in obj.items():
            path = f"{prefix}{k}"
            if isinstance(v, (dict, list)):
                flat.update(flatten(v, path + "."))
            else:
                flat[path] = v
    elif isinstance(obj, list):
        for i, item in enumerate(obj):
            flat.update(flatten(item, f"{prefix}[{i}]."))
    return flat

def parse_type_b(line):
    # 1) Strip off everything before the payload
    after_dash = line.split("] - ", 1)[1] if "] - " in line else line

    # 2) Metadata is up to and including the first "~#~" before JSON
    idx = after_dash.find("~#~{")
    if idx != -1:
        metadata = after_dash[:idx+3]  # include "~#~"
        rest      = after_dash[idx+3:] # starts at "{"
    else:
        metadata = after_dash
        rest     = ""

    # 3) Split rest on "~#~", take only those that begin with "{"
    parts = rest.split("~#~")
    json_parts = [p for p in parts if p.strip().startswith("{")]

    # 4) Reconstruct payload (just the JSON bits, joined by "~#~")
    payload = "~#~".join(json_parts)

    # 5) Flatten each JSON part under payload[i].
    flat = {}
    for i, jp in enumerate(json_parts):
        try:
            obj = json.loads(jp)
            for k, v in flatten(obj).items():
                flat[f"payload[{i}].{k}"] = v
        except json.JSONDecodeError:
            flat[f"payload[{i}].parse_error"] = "invalid JSON"

    return {
        "metadata": metadata,
        "payload":  payload,
        **flat
    }

def main():
    # Read lines
    lines = []
    with open(INPUT_FILE, encoding="utf-8", errors="ignore") as f:
        for idx, ln in enumerate(f, start=1):
            txt = ln.rstrip("\n")
            if txt.strip():
                lines.append((idx, txt))

    # Parse only Type B
    records = []
    for line_no, line in tqdm(lines, desc="Parsing Type B logs"):
        if not is_type_b(line):
            continue
        data = parse_type_b(line)
        data["line_no"] = line_no
        records.append(data)

    # Write to Excel
    wb = xlsxwriter.Workbook(OUTPUT_FILE)
    ws = wb.add_worksheet("TypeB_Validation")

    # Dynamic headers
    headers = []
    for rec in records:
        for k in rec:
            if k not in headers:
                headers.append(k)

    # Write headers
    for c, h in enumerate(headers):
        ws.write(0, c, h)

    # Write rows
    for r, rec in enumerate(records, start=1):
        for c, h in enumerate(headers):
            ws.write(r, c, rec.get(h, ""))

    wb.close()
    print(f"Validation workbook '{OUTPUT_FILE}' with {len(records)} rows written.")

if __name__ == "__main__":
    main()
